webgazer.begin();
let captureInterval;

async function startCapture() {
    try {
        // 디스플레이(스크린)에서 미디어(영상) 스트림을 비동기적으로 가져오는 JavaScript의 명령입니다
        const mediaStream = await navigator.mediaDevices.getDisplayMedia({ video: true });    

        // 5초마다 캡처
        // captureInterval = setInterval(() => {
        //     captureFrame(mediaStream);
        // }, 5000);
        captureFrame(mediaStream);
    } catch(err) {
        console.error("Error: " + err);
    }
}

function stopCapture() {
    clearInterval(captureInterval);

    let tracks = videoElem.srcObject.getTracks();
    tracks.forEach(track => track.stop());
    videoElem.srcObject = null;
}

async function captureFrame(mediaStream) {
    var startX = 0; // 시작점 x좌표
    var startY = 0; // 시작점 y좌표
    const width = 500; // 가로 길이
    const height = 500; // 세로 길이

    await webgazer.getCurrentPrediction().then(prediction => {
        if (prediction) {
            startX = prediction.x;
            startY = prediction.y;
            console.log(`여기서 안 바뀜? - X: ${startX}, Y: ${startY}`);
        }
    });


    // 화면 들고오기
    const videoTrack = mediaStream.getVideoTracks()[0];
    console.log(`Current Prediction - X: ${startX}, Y: ${startY}`);
    // videoTrack을 이용하여 ImageCapture 객체를 생성합니다. ImageCapture는 비디오 트랙에서 이미지를 캡처할 수 있는 API입니다.
    const imageCapture = new ImageCapture(videoTrack);
    
    // 좌표 설정 (시작점과 가로, 세로 길이)
    
    // grabFrame 메소드를 호출하여 현재 비디오 트랙에서 프레임을 캡처합니다. 이 메소드는 Promise를 반환하며,
    // 성공 시 imageBitmap 객체를 반환합니다.
    imageCapture.grabFrame()
        .then(async imageBitmap => {
            // canvas 요소를 동적으로 생성하고, 캡처한 이미지의 크기에 맞게 크기를 설정합니다.
            // canvas의 2D 렌더링 컨텍스트를 가져와서 imageBitmap을 그립니다.
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const context = canvas.getContext('2d');
            context.drawImage(imageBitmap, startX, startY, width, height, 0, 0, width, height);
            

            const base64Image = canvas.toDataURL().split(',')[1]; // 이미지를 Base64로 인코딩
            console.log("Base64 Image:", base64Image); // 인코딩된 이미지 출력

            // 인코딩된 이미지를 OpenAI API로 전송하여 답변을 받음
            const aiResponse = await fetchAIResponse(base64Image);
            console.log(aiResponse)
            addMessage('챗봇', aiResponse);
            // canvas.toBlob 메소드를 사용하여 캔버스의 내용을 블롭(Blob)으로 변환합니다.
            // 블롭을 가리키는 URL을 생성하고, 이를 a 태그의 href 속성에 할당합니다.
            // 다운로드 속성을 설정하여 파일 이름을 'screenshot.png'로 지정하고, a 태그를 클릭하여 파일을 다운로드합니다.
            
            canvas.toBlob(blob => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'screenshot.png';
                a.click();
                URL.revokeObjectURL(url);
            });

            const canvasContainer = document.getElementById('canvas-container');
            canvasContainer.appendChild(canvas);

            console.log(canvas);
        })
        .catch(error => console.error("Frame capture error:", error));
}











// 채팅 메시지를 표시할 DOM
const chatMessages = document.querySelector('#chat-messages');
// 사용자 입력 필드
const imageInput = document.querySelector('#user-input input');
// 전송 버튼
const sendButton = document.querySelector('#user-input button');
// 발급받은 OpenAI API 키를 변수로 저장
const apiKey = '';
// OpenAI API 엔드포인트 주소를 변수로 저장
const apiEndpoint = 'https://api.openai.com/v1/chat/completions'
function addMessage(sender, message) {
    // 새로운 div 생성
    const messageElement = document.createElement('div');
    // 생성된 요소에 클래스 추가
    messageElement.className = 'message';
     // 채팅 메시지 목록에 새로운 메시지 추가
    messageElement.textContent = `${sender}: ${message}`;
    chatMessages.prepend(messageElement);
}
// ChatGPT API 요청
async function fetchAIResponse(base64_image) {
    // console.log(base64_image);
    // API 요청에 사용할 옵션을 정의
    const requestOptions = {
        method: 'POST',
        // API 요청의 헤더를 설정
        headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
        },
        body: JSON.stringify({
            model: "gpt-4o",  // 사용할 AI 모델
            messages: [{
                role: "user", // 메시지 역할을 user로 설정
                content: [
                    {"type": "text", "text": "What is this image?"},
                    {"type": "image_url", "image_url": {"url": `data:image/jpeg;base64,${base64_image}`}}
                ]
            }, ],
            temperature: 0.8, // 모델의 출력 다양성
            max_tokens: 300, // 응답받을 메시지 최대 토큰(단어) 수 설정
            top_p: 1, // 토큰 샘플링 확률을 설정
            frequency_penalty: 0.5, // 일반적으로 나오지 않는 단어를 억제하는 정도
            presence_penalty: 0.5, // 동일한 단어나 구문이 반복되는 것을 억제하는 정도
            stop: ["Human"], // 생성된 텍스트에서 종료 구문을 설정
        }),

    };
    // API 요청후 응답 처리
    try {
        const response = await fetch(apiEndpoint, requestOptions);
        const data = await response.json();
        const aiResponse = data.choices[0].message.content;
        return aiResponse;
    } catch (error) {
      console.error('OpenAI API 호출 중 오류 발생:', error);
        return 'OpenAI API 호출 중 오류 발생';
    }
}
// 전송 버튼 클릭 이벤트 처리
sendButton.addEventListener('click', async () => {
    // 사용자가 선택한 이미지 파일
    const file = imageInput.files[0];
    // 이미지 파일이 없으면 리턴
    if (!file) {
        alert('이미지를 선택하세요.');
        return;
    }
    // 이미지를 Base64로 인코딩
    const base64Image = await encodeImage(file);
    // 이미지를 사용자 메시지 화면에 추가
    addMessage('나', `사용자가 이미지를 전송했습니다: ${file.name}`);
    // 이미지 파일을 OpenAI API로 전송하여 답변을 받음
    const aiResponse = await fetchAIResponse(base64Image);
    // 챗봇 답변을 화면에 추가
    addMessage('챗봇', aiResponse);
});
// // 사용자 입력 필드에서 Enter 키 이벤트를 처리
// userInput.addEventListener('keydown', (event) => {
//     if (event.key === 'Enter') {
//         sendButton.click();
// //     }
// });

// 이미지를 Base64로 인코딩하는 함수
async function encodeImage(imageFile) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result.split(',')[1]);
        reader.onerror = error => reject(error);
        reader.readAsDataURL(imageFile);
    });
}
